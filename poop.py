import google.generativeai as genai
import os
import traceback
import subprocess
import sys
import shutil
import time
import platform
import random
from PIL import Image
import re # Added for plan parsing

GAK = os.environ.get("GOOGLE_API_KEY")
M_CURRENT_TEXT_MODEL = None
M_MULTI_CAPABLE_MODEL = None
M_LIGHT_MODEL = None
# GCFG = genai.types.GenerationConfig(temperature=0.3)
# Updated GCFG to allow for potentially more creative/structured plan output if needed,
# but can be kept at 0.3 for consistency. For planning, slightly higher temp might be okay.
# For code gen, 0.3 is good. Let's use one GCFG for now.
GCFG = genai.types.GenerationConfig(temperature=0.4, candidate_count=1)


CURRENT_TARGET_FILE = None
LAST_USER_INSTRUCTION = "print('Hello from POOP!')" # This will store the high-level goal for a plan
LAST_SUCCESSFUL_TASK_DESCRIPTION = ""

POOP_NAME = "Programmatic Operations Optimization Protocol"
FAREWELL = "Valete!"

LINK_START = "\x1b]8;;"
LINK_END = "\x1b\\"
LINK_RESET = "\x1b]8;;\x1b\\"
API_KEY_LINK = f"{LINK_START}https://makersuite.google.com/app/apikey{LINK_END}makersuite.google.com/app/apikey{LINK_RESET}"

ACTIVE_SUBPROCESS = None
ACTIVE_SUBPROCESS_FILE = None

CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = False
LAST_CODE_FOR_CONFIRMATION = ""

# --- Plan-related global variables ---
CURRENT_PLAN_TEXT = ""      # Raw text of the plan from LLM
CURRENT_PLAN_STEPS = []     # Parsed list of step dictionaries
PLAN_CONFIRMED = False
PLAN_STEP_INDEX = 0
# --- End Plan-related global variables ---

COLORS = [
    "\x1b[31m", "\x1b[32m", "\x1b[33m", "\x1b[34m", "\x1b[35m", "\x1b[36m",
    "\x1b[91m", "\x1b[92m", "\x1b[93m", "\x1b[94m", "\x1b[95m", "\x1b[96m",
]
RESET_COLOR = "\x1b[0m"
BRIGHT_WHITE_COLOR = "\x1b[97m"

IMAGE_ANALYSIS_SIGNAL = "#POOP_ANALYZE_IMAGE_PATH:"

_CMDS_TEMPLATE = f"""CMDS for POOP ({POOP_NAME}):
h(elp): Show this help.
q(uit)/exit: Exit the agent.
run: If new/modified Python code exists, show for confirmation, then execute it
     (blocking, live output) and attempt to debug errors. Updates last successful task.
     If script signals for image analysis, POOP will attempt it.
start [path]: Start Python code in the target file in the background (live output).
              No confirmation before start; assumes code is tested.
              If no path given, uses the current target file. If none, a new unique file is created.
stop: Stop the last background process started with 'start'.
status_process: Check the status of the background process.
show: Display the current Python code buffer and active plan (if any).
clear: Clear Python code buffer, task history, and active plan. Resets confirmation status and target file.
m(odel) [name]: Change the default LLM. Available: '{{multi_model_name}}', '{{light_model_name}}'.
img_desc [path]: Describe an image using POOP's multimodal AI.
f(ile) [path]: Set the Python target file. 'f none' for in-memory.
               Loads code if file exists, resets confirmation and task history.
sysinfo: Display detected system information.
[any other text]: Generate a plan for the instruction. If confirmed, POOP will attempt
                  to execute the plan step-by-step, generating and running code as needed.
                  If a plan step's script implies taking a screenshot AND describing it,
                  the generated script should print '{IMAGE_ANALYSIS_SIGNAL} <filepath>'
                  to stdout upon successful screenshot creation for POOP to analyze.
                  Code directly generated by a plan step is NOT shown for individual confirmation
                  before running if the overall plan was approved.
"""
CMDS = ""

def print_poop_ascii_art():
    art = [
        r"  #####   #####   #####  #####  ",
        r"  #    # #     # #     # #    # ",
        r"  #    # #     # #     # #    # ",
        r"  #####  #     # #     # #####  ",
        r"  #      #     # #     # #      ",
        r"  #      #     # #     # #      ",
        r"  #       #####   #####  #      "
    ]
    art_color = BRIGHT_WHITE_COLOR
    for line in art:
        print(f"{art_color}{line}{RESET_COLOR}")
    print()

def get_system_info():
    info = {
        "sys_platform": sys.platform,
        "platform_system": platform.system(),
        "platform_release": platform.release(),
        "platform_version": platform.version(),
        "os_name": os.name,
        "architecture": platform.machine(),
        "python_version": sys.version.split()[0]
    }
    if info["platform_system"] == "Linux":
        info["linux_distro_name"] = "N/A"
        info["linux_distro_id"] = "N/A"
        info["linux_distro_version_id"] = "N/A"
        try:
            with open("/etc/os-release") as f:
                for line_content in f:
                    if '=' in line_content:
                        key, value = line_content.strip().split('=', 1)
                        value = value.strip('"').strip("'")
                        if key == "NAME": info["linux_distro_name"] = value
                        elif key == "VERSION_ID": info["linux_distro_version_id"] = value
                        elif key == "ID": info["linux_distro_id"] = value
        except FileNotFoundError: pass
        except Exception: pass
    return info

def generate_unique_poop_filename():
    timestamp = int(time.time() * 1000)
    filename = f"poop{timestamp}.py"
    return os.path.abspath(filename)

def update_cmds_display():
    global CMDS
    default_file_display = CURRENT_TARGET_FILE if CURRENT_TARGET_FILE else "new unique file on generation/run"
    multi_name = M_MULTI_CAPABLE_MODEL.model_name if M_MULTI_CAPABLE_MODEL else 'N/A'
    light_name = M_LIGHT_MODEL.model_name if M_LIGHT_MODEL else 'N/A'
    CMDS = _CMDS_TEMPLATE.format(
        current_default_file=default_file_display,
        multi_model_name=multi_name,
        light_model_name=light_name,
        IMAGE_ANALYSIS_SIGNAL=IMAGE_ANALYSIS_SIGNAL
    )

def init_llm(model_name_primary='gemini-2.5-flash-preview-05-20', model_name_secondary='gemini-2.0-pro'): 
    global GAK, M_CURRENT_TEXT_MODEL, M_MULTI_CAPABLE_MODEL, M_LIGHT_MODEL
    if not GAK: return False
    try:
        genai.configure(api_key=GAK)
        try:
            M_MULTI_CAPABLE_MODEL = genai.GenerativeModel(model_name_primary)
            print(f"Primary LLM ({model_name_primary}): Initialized.")
        except Exception as e: print(f"!Init {model_name_primary} (Primary) FAILED: {e}"); M_MULTI_CAPABLE_MODEL = None
        if model_name_primary != model_name_secondary:
            try:
                M_LIGHT_MODEL = genai.GenerativeModel(model_name_secondary)
                print(f"Secondary LLM ({model_name_secondary}): Initialized.")
            except Exception as e: print(f"!Init {model_name_secondary} (Secondary) FAILED: {e}"); M_LIGHT_MODEL = None
        elif M_MULTI_CAPABLE_MODEL : M_LIGHT_MODEL = M_MULTI_CAPABLE_MODEL; print(f"Secondary LLM is same as Primary ({model_name_secondary}).")

        if M_MULTI_CAPABLE_MODEL: M_CURRENT_TEXT_MODEL = M_MULTI_CAPABLE_MODEL
        elif M_LIGHT_MODEL: M_CURRENT_TEXT_MODEL = M_LIGHT_MODEL; print("!Warning: Primary model failed, using secondary model as current text model.")

        if M_CURRENT_TEXT_MODEL: print(f"Current text model set to: {M_CURRENT_TEXT_MODEL.model_name}")
        else: print("!No LLM could be initialized as current text model."); update_cmds_display(); return False
        update_cmds_display(); return True
    except Exception as e:
        print(f"!General LLM Init FAILED: {e}")
        M_CURRENT_TEXT_MODEL = M_MULTI_CAPABLE_MODEL = M_LIGHT_MODEL = None
        update_cmds_display(); return False

def gmp(user_instruction_for_plan, system_info_for_plan): # Generate Multi-step Plan
    """Generates a multi-step plan using the LLM."""
    planning_model = M_MULTI_CAPABLE_MODEL if M_MULTI_CAPABLE_MODEL else M_CURRENT_TEXT_MODEL
    if not planning_model: return "#LLM_ERR: No suitable model for planning."

    system_info_str = "\n".join([f"{k.replace('_', ' ').title()}: {v}" for k, v in system_info_for_plan.items()])

    prompt = f"""You are POOP, an AI assistant that helps users by creating and executing Python code.
Before generating any code for a complex user request, you MUST first create a detailed, step-by-step plan.
The user request is: "{user_instruction_for_plan}"

Target System Information:
---
{system_info_str}
---

Instructions for creating the plan:
1.  Break the request into a sequence of logical, manageable, and executable steps.
2.  Each step should be numbered (e.g., 1., 2., 3.).
3.  For each step, clearly define:
    -   `Task:` A concise description of the action to be performed in this step.
    -   `Details:` (Optional) Any specific methods, tools, or considerations for this step.
    -   `Dependencies:` (Optional) What this step relies on (e.g., output from a previous step, specific libraries, external tools, user-provided information).
    -   `Outcome:` What will be achieved or produced by successfully completing this step.
    -   `Requires_Code_Gen:` (Yes/No) Does POOP need to generate Python code for this step? If "No", POOP will not attempt to generate code for this step.
    -   `Additive_Code:` (Yes/No, only if Requires_Code_Gen is Yes) Should the code for this step be added to the code from the previous step, or is it a standalone script/modification? Default to No if unsure.
    -   `Requires_User_Input_During_Step:` (Optional, text description) If the Python script for this step will need to prompt the user for specific input (e.g., API keys, file paths, choices), describe what input is needed. POOP will instruct the code generation model to include these prompts.
    -   `Requires_User_Action:` (Optional, text description, typically if Requires_Code_Gen is No) If this step requires the user to perform a manual action outside of POOP (e.g., "Manually download X from Y website", "Create an account at Z"), describe the action. POOP will pause and wait for user confirmation after displaying this.
    -   `Screenshot_Analysis_Signal:` (Yes/No, only if Requires_Code_Gen is Yes) If this step involves code that takes a screenshot AND POOP is then expected to analyze that screenshot using its multimodal AI, set this to Yes. The generated code should then print '{IMAGE_ANALYSIS_SIGNAL} <filepath>'.

Example of a good plan format for a step:
1.  Task: Take a screenshot of the entire screen and save it.
    Details: Use a cross-platform library like 'mss' or platform-specific tools via subprocess.
    Dependencies: Python environment.
    Outcome: Screenshot image file saved to disk (e.g., 'screenshot.png').
    Requires_Code_Gen: Yes
    Additive_Code: No
    Requires_User_Input_During_Step: None
    Screenshot_Analysis_Signal: Yes (if the next step is to analyze it, otherwise No)

Return ONLY the numbered plan. Do not add conversational fluff before or after the plan. Start directly with "1. Task: ...".
Make sure to clearly state `Requires_Code_Gen: Yes` or `Requires_Code_Gen: No` for every step.
If `Requires_Code_Gen: No`, then `Additive_Code` and `Screenshot_Analysis_Signal` are not applicable (can be omitted or set to No).
"""
    try:
        response = planning_model.generate_content(prompt, generation_config=GCFG)
        plan_output = response.text.strip()
        # print(f"DEBUG: Raw plan output from LLM:\n{plan_output}") # For debugging plan generation
        return plan_output
    except Exception as e:
        return f"#LLM_ERR: Error during plan generation with {planning_model.model_name}: {e}\n{traceback.format_exc()}"

def parse_plan_step_details(step_text_content):
    details = {}
    def extract_field(field_name, text, stop_keywords):
        pattern = rf"{field_name}:\s*(.*?)(?=(" + "|".join(stop_keywords) + r")|$)"
        match = re.search(pattern, text, re.DOTALL | re.IGNORECASE)
        return match.group(1).strip() if match and match.group(1) else None

    all_fields = ["Task", "Details", "Dependencies", "Outcome", "Requires_Code_Gen", "Additive_Code", "Requires_User_Input_During_Step", "Requires_User_Action", "Screenshot_Analysis_Signal"]
    
    current_field_map = {
        "Task": "task", "Details": "details", "Dependencies": "dependencies", "Outcome": "outcome",
        "Requires_Code_Gen": "requires_code_gen", "Additive_Code": "additive_code",
        "Requires_User_Input_During_Step": "requires_user_input_during_step",
        "Requires_User_Action": "requires_user_action",
        "Screenshot_Analysis_Signal": "screenshot_analysis_signal"
    }

    for i, field_name_caps in enumerate(all_fields):
        # Define stop_keywords as all subsequent fields or end of string
        stop_kws = [f_kw + ":" for f_kw in all_fields[i+1:]]
        value = extract_field(field_name_caps, step_text_content, stop_kws)
        if value:
            field_key = current_field_map[field_name_caps]
            if field_key in ["requires_code_gen", "additive_code", "screenshot_analysis_signal"]:
                details[field_key] = (value.lower() == "yes")
            else:
                details[field_key] = value
    
    if not details.get("task"): # Fallback for task if not explicitly tagged but is the first part
        first_meaningful_line = ""
        for line in step_text_content.splitlines():
            if line.strip() and not any(f"{kw}:" in line for kw in all_fields[1:]): # if not other keywords
                first_meaningful_line = line.strip()
                break
        if first_meaningful_line and not details.get("task"):
             # Check if it's just the step number again
            if not re.match(r"^\d+\.\s*", first_meaningful_line):
                details["task"] = first_meaningful_line

    # Defaults for boolean flags if not found
    if "requires_code_gen" not in details: details["requires_code_gen"] = True # Default to needing code
    if details["requires_code_gen"] and "additive_code" not in details: details["additive_code"] = False
    if details["requires_code_gen"] and "screenshot_analysis_signal" not in details: details["screenshot_analysis_signal"] = False

    return details


def parse_plan(plan_text_input):
    parsed_steps_list = []
    # Regex to find steps starting with a number, dot, and optional space.
    # Captures step number and the text of the step until the next step or end of string.
    step_pattern = re.compile(r"^\s*\d+\.\s*(.*?)(?=(?:\n\s*\d+\.\s*)|$)", re.MULTILINE | re.DOTALL)
    
    matches = list(step_pattern.finditer(plan_text_input))

    if not matches and plan_text_input.strip(): # If regex fails but there's text, treat as single step
        # print("DEBUG: parse_plan - Regex found no steps, treating as single step.")
        step_data = parse_plan_step_details(plan_text_input.strip())
        if step_data.get("task"):
            parsed_steps_list.append(step_data)
        elif plan_text_input.strip(): # If still no task, use the whole text as task
             parsed_steps_list.append({"task": plan_text_input.strip(), "requires_code_gen": True, "additive_code": False, "screenshot_analysis_signal": False})
        return parsed_steps_list

    for match in matches:
        step_content = match.group(1).strip()
        if not step_content:
            # print(f"DEBUG: parse_plan - Skipping empty step content for match: {match.group(0)}")
            continue
        
        # print(f"DEBUG: parse_plan - Processing step content:\n{step_content}")
        step_data = parse_plan_step_details(step_content)
        
        if step_data.get("task"):
            parsed_steps_list.append(step_data)
            # print(f"DEBUG: parse_plan - Successfully parsed step: {step_data['task']}")
        else:
            # Fallback: if task parsing failed, use the raw content (minus keywords) as task
            # This is a bit crude but better than discarding the step
            raw_task_text = re.sub(r"(Details:|Dependencies:|Outcome:|Requires_Code_Gen:|Additive_Code:|Requires_User_Input_During_Step:|Requires_User_Action:|Screenshot_Analysis_Signal:).*", "", step_content, flags=re.DOTALL | re.IGNORECASE).strip()
            if raw_task_text:
                step_data["task"] = raw_task_text
                if "requires_code_gen" not in step_data: step_data["requires_code_gen"] = True # Default again
                if "additive_code" not in step_data and step_data["requires_code_gen"]: step_data["additive_code"] = False
                if "screenshot_analysis_signal" not in step_data and step_data["requires_code_gen"]: step_data["screenshot_analysis_signal"] = False
                parsed_steps_list.append(step_data)
                # print(f"DEBUG: parse_plan - Parsed step with fallback task: {step_data['task']}")
            # else:
                # print(f"DEBUG: parse_plan - Failed to parse task even with fallback for content: '{step_content[:100]}...'")
    
    return parsed_steps_list


def gmc(current_code="", user_instruction_for_code_gen=LAST_USER_INSTRUCTION, error_feedback=None, previous_task_context_for_code_gen="", system_info_for_code_gen=None, plan_context_for_code_gen=None):
    global CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN
    if not M_CURRENT_TEXT_MODEL: return "#LLM_ERR: Current text model not initialized."

    prompt_parts = [
        "You are a Python expert. Your task is to create, modify, or debug Python scripts step-by-step.",
        "The scripts can perform any task, including file system operations, external processes, network requests, etc.",
        "Use standard libraries. Add necessary imports. Return ONLY raw Python code. No markdown or explanations outside code."
    ]
    # This specific instruction about screenshot signal is duplicated here and in gmp, which is fine.
    # It ensures both planner and code generator are aware.
    screenshot_signal_instruction = (
        f"If a task involves taking a screenshot AND then describing/analyzing its content (e.g., plan_context indicates Screenshot_Analysis_Signal: Yes), "
        f"the script should, after successfully saving the screenshot, print a special line to standard output: "
        f"'{IMAGE_ANALYSIS_SIGNAL} /path/to/the/saved/screenshot.png'. Replace '/path/to/the/saved/screenshot.png' with the actual absolute path of the saved image file. "
        f"POOP will detect this signal and perform the AI image analysis."
    )
    prompt_parts.append(screenshot_signal_instruction)


    if system_info_for_code_gen:
        prompt_parts.append("\n--- TARGET SYSTEM INFORMATION ---")
        for key, value in system_info_for_code_gen.items(): prompt_parts.append(f"{key.replace('_', ' ').title()}: {value}")
        prompt_parts.append("---------------------------------")
        prompt_parts.append("Adapt your Python script (especially for OS commands, package management, or file paths) to this target system.")

    if plan_context_for_code_gen:
        prompt_parts.append("\n--- EXECUTING PART OF A PLAN ---")
        prompt_parts.append(f"Overall Goal (from original user request): {LAST_USER_INSTRUCTION}") # High-level goal
        if plan_context_for_code_gen.get("full_plan"):
             prompt_parts.append("Full Plan Provided by POOP's Planner:")
             prompt_parts.append(plan_context_for_code_gen["full_plan"])
        if plan_context_for_code_gen.get("current_step_description"):
             prompt_parts.append(f"Current Step to Implement: {plan_context_for_code_gen['current_step_description']}")
        if plan_context_for_code_gen.get("current_step_details"):
             prompt_parts.append(f"Details for Current Step: {plan_context_for_code_gen['current_step_details']}")
        if previous_task_context_for_code_gen: # Context from *previous plan step's execution*
             prompt_parts.append(f"Context/Output from previous step: {previous_task_context_for_code_gen}")
        prompt_parts.append("---------------------------------")
        prompt_parts.append(f"Based on this plan context, generate Python code for the CURRENT STEP: {plan_context_for_code_gen.get('current_step_description','N/A')}.")
        if plan_context_for_code_gen.get("requires_user_input_during_step"):
            prompt_parts.append(f"The script for this step MUST prompt the user for the following information if needed: {plan_context_for_code_gen['requires_user_input_during_step']}")
        if plan_context_for_code_gen.get("screenshot_analysis_signal"):
            prompt_parts.append(f"This step is marked with Screenshot_Analysis_Signal: Yes. Ensure the script prints '{IMAGE_ANALYSIS_SIGNAL} <filepath>' if it saves a screenshot for analysis.")

    if error_feedback:
        prompt_parts.append("\nTASK: Fix the Python code based on the error.")
        if plan_context_for_code_gen and plan_context_for_code_gen.get("current_step_description"):
            prompt_parts.append(f"The script was intended to achieve this plan step: {plan_context_for_code_gen['current_step_description']}")
        elif previous_task_context_for_code_gen : prompt_parts.append(f"The overall goal of the script (related to previous step/task) was: {previous_task_context_for_code_gen}")
        prompt_parts.append(f"The specific instruction/task for this code was: {user_instruction_for_code_gen}")
        prompt_parts.append(f"FAULTY PYTHON CODE:\n```python\n{current_code}\n```")
        prompt_parts.append(f"ERROR MESSAGE:\n```\n{error_feedback}\n```")
        prompt_parts.append("FIXED PYTHON CODE (code only):")
    elif current_code: # Modifying existing code
        prompt_parts.append("\nTASK: Modify or add to the existing Python script.")
        if plan_context_for_code_gen and plan_context_for_code_gen.get("current_step_description"):
             prompt_parts.append(f"This modification is for the plan step: {plan_context_for_code_gen['current_step_description']}")
        elif previous_task_context_for_code_gen:
            prompt_parts.append(f"The script so far (from previous successful steps/plan) has achieved: {previous_task_context_for_code_gen}")
            prompt_parts.append("Consider this context when fulfilling the new instruction for the current step.")
        prompt_parts.append(f"CURRENT SCRIPT (may be from a previous plan step or ad-hoc): \n```python\n{current_code}\n```")
        prompt_parts.append(f"NEW INSTRUCTION (for current step or modification): {user_instruction_for_code_gen}")
        prompt_parts.append("MODIFIED OR EXTENDED PYTHON SCRIPT (code only):")
        CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = True
    else: # Generating new code
        prompt_parts.append("\nTASK: Create a new Python script.")
        if plan_context_for_code_gen and plan_context_for_code_gen.get("current_step_description"):
            prompt_parts.append(f"This new script is for the plan step: {plan_context_for_code_gen['current_step_description']}")
        elif previous_task_context_for_code_gen: prompt_parts.append(f"This new script might be related to a previous broader goal or plan: {previous_task_context_for_code_gen}")
        prompt_parts.append(f"INSTRUCTION FOR THE NEW SCRIPT (for current step or ad-hoc): {user_instruction_for_code_gen}")
        prompt_parts.append("PYTHON SCRIPT (code only):")
        CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = True

    full_prompt = "\n".join(prompt_parts)
    # print(f"DEBUG: GMC Full prompt:\n{full_prompt[:1000]}...") # For debugging
    try:
        response = M_CURRENT_TEXT_MODEL.generate_content(full_prompt, generation_config=GCFG)
        output = response.text.strip()
        if output.startswith("```python"): output = output[9:]
        elif output.startswith("```"): output = output[3:]
        if output.endswith("```"): output = output[:-3]
        return output.strip()
    except Exception as e: return f"#LLM_ERR: Error during Python code generation with {M_CURRENT_TEXT_MODEL.model_name}: {e}\n{traceback.format_exc()}"


def gmc_multimodal(image_data, text_prompt="Describe this image in detail."):
    active_multimodal_model = M_MULTI_CAPABLE_MODEL if M_MULTI_CAPABLE_MODEL else M_CURRENT_TEXT_MODEL
    if not active_multimodal_model: return "#LLM_ERR: No suitable multimodal model initialized."
    content = [text_prompt, image_data]
    try:
        response = active_multimodal_model.generate_content(content, generation_config=GCFG)
        return response.text.strip()
    except Exception as e: return f"#LLM_ERR: Error during multimodal generation with {active_multimodal_model.model_name if active_multimodal_model else 'N/A'}: {e}"

def create_execution_scope():
    s = {"__builtins__": __builtins__}
    libs = [('os', 'os'), ('sys', 'sys'), ('subprocess', 'sp'), ('shutil', 'sh'), ('platform', 'platform'),
            ('requests', 'req'), ('json', 'json'), ('time', 'time'), ('random', 'random'), ('datetime', 'datetime'),
            ('pandas', 'pd'), ('numpy', 'np'), ('matplotlib.pyplot', 'plt')]
    # Try to import mss for screenshots, common in such agents
    try: import mss; s['mss'] = mss
    except ImportError: pass
    for lib_name, alias in libs:
        try: exec(f"import {lib_name} as {alias}", s)
        except ImportError: pass
    return s

def execute_code(code_buffer_to_exec, last_instruction_for_fix, previous_task_context_for_fix, file_path=None, auto_run_source=""):
    if not code_buffer_to_exec or not code_buffer_to_exec.strip():
        print("!No Python code to execute (empty or whitespace only)."); return code_buffer_to_exec, False, False, []

    print(f"{auto_run_source}Executing Python code ({'File: ' + file_path if file_path else 'In-Memory'})...")
    fixed_this_run = False
    execution_successful = False
    error_output_for_llm = None
    current_system_info_for_fix = get_system_info()
    stdout_lines_capture = []
    # Determine plan context for fixing, if any
    plan_context_for_fix = None
    if PLAN_CONFIRMED and CURRENT_PLAN_STEPS and PLAN_STEP_INDEX < len(CURRENT_PLAN_STEPS):
        current_step_fix = CURRENT_PLAN_STEPS[PLAN_STEP_INDEX]
        plan_context_for_fix = {
            "full_plan": CURRENT_PLAN_TEXT,
            "current_step_description": current_step_fix.get('task', 'N/A'),
            "current_step_details": current_step_fix.get('details', 'N/A'),
            "requires_user_input_during_step": current_step_fix.get('requires_user_input_during_step'),
            "screenshot_analysis_signal": current_step_fix.get('screenshot_analysis_signal', False)
        }

    if file_path:
        try:
            with open(file_path, "w", encoding='utf-8') as f: f.write(code_buffer_to_exec)
            child_env = os.environ.copy(); child_env["PYTHONUNBUFFERED"] = "1"
            process = subprocess.Popen(
                [sys.executable, file_path],
                stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True,
                bufsize=1, encoding='utf-8', env=child_env
            )
            stderr_capture_list = []
            print("--- Live Python Output Start ---", flush=True)
            if process.stdout:
                for line in iter(process.stdout.readline, ""):
                    sys.stdout.write(line); sys.stdout.flush(); stdout_lines_capture.append(line.strip())
                process.stdout.close()
            if process.stderr:
                for line in iter(process.stderr.readline, ""):
                    sys.stderr.write(line); sys.stderr.flush(); stderr_capture_list.append(line.strip())
                process.stderr.close()
            process.wait(); return_code = process.returncode
            print("\n--- Live Python Output End ---", flush=True)

            if return_code != 0:
                error_output_for_llm = "\n".join(stderr_capture_list)
                print(f"!Python process finished with error code {return_code}.")
                print("Attempting to fix...")
                fixed_code = gmc(code_buffer_to_exec, last_instruction_for_fix, error_output_for_llm, previous_task_context_for_fix, current_system_info_for_fix, plan_context_for_fix)
                if fixed_code.startswith("#LLM_ERR"): print(fixed_code)
                elif fixed_code == code_buffer_to_exec: print("LLM: No change (error not fixed).")
                else: print("Fixed."); code_buffer_to_exec = fixed_code; fixed_this_run = True
            else: print("Python execution OK."); execution_successful = True
        except FileNotFoundError: print(f"!ERROR: Python interpreter '{sys.executable}' not found.")
        except Exception as e:
            print(f"!FILE EXECUTION ERROR (Python): {e}")
            error_output_for_llm = f"File system/Subprocess error: {e}\n{traceback.format_exc()}"
            print("Attempting to fix...")
            fixed_code = gmc(code_buffer_to_exec, last_instruction_for_fix, error_output_for_llm, previous_task_context_for_fix, current_system_info_for_fix, plan_context_for_fix)
            if fixed_code.startswith("#LLM_ERR"): print(fixed_code)
            elif fixed_code == code_buffer_to_exec: print("LLM: No change.")
            else: print("Fixed."); code_buffer_to_exec = fixed_code; fixed_this_run = True
    else: # In-memory execution (discouraged for complex tasks, but kept for simple ones if needed)
        original_stdout = sys.stdout
        from io import StringIO
        captured_output = StringIO()
        sys.stdout = captured_output # Redirect stdout

        execution_scope, compiled_object, compile_error_msg = create_execution_scope(), None, None
        try: compiled_object = compile(code_buffer_to_exec, '<in_memory_code>', 'exec')
        except SyntaxError as se:
            compile_error_msg = f"SYNTAX ERROR Line {se.lineno}: {se.msg} `{(se.text or '').strip()}`\n{traceback.format_exc(limit=0)}"

        if compile_error_msg:
            sys.stdout = original_stdout # Restore stdout
            print(f"COMPILE ERROR (Python): {compile_error_msg.splitlines()[0]}"); print("Attempting to fix...")
            error_output_for_llm = compile_error_msg
            fixed_code = gmc(code_buffer_to_exec, last_instruction_for_fix, error_output_for_llm, previous_task_context_for_fix, current_system_info_for_fix, plan_context_for_fix)
            if fixed_code.startswith("#LLM_ERR"): print(fixed_code)
            elif fixed_code == code_buffer_to_exec: print("LLM: No change.")
            else: print("Fixed."); code_buffer_to_exec = fixed_code; fixed_this_run = True
        elif compiled_object:
            execution_scope['__name__'] = '__main__'
            print_to_original_stdout = lambda *args, **kwargs: print(*args, file=original_stdout, **kwargs)
            print_to_original_stdout("--- Live Python Output Start (In-Memory) ---", flush=True)
            try:
                exec(compiled_object, execution_scope, execution_scope)
                print_to_original_stdout("\nPython execution OK."); execution_successful = True
            except SystemExit: print_to_original_stdout("\nExited."); execution_successful = True
            except KeyboardInterrupt: print_to_original_stdout("\nInterrupted.")
            except Exception as e:
                sys.stdout = original_stdout # Restore stdout before printing error
                tb_lines = traceback.format_exc().splitlines()
                specific_error_line = f"RUNTIME ERROR (Python): {type(e).__name__}: {e}"
                for tbl_line in reversed(tb_lines):
                    if '<in_memory_code>' in tbl_line:
                        specific_error_line = f"RUNTIME ERROR (Python): {type(e).__name__}: {e} (Near: {tbl_line.strip()})"; break
                error_output_for_llm = f"{type(e).__name__}: {e}\n" + "\n".join(tb_lines)
                print(f"\n{specific_error_line}"); print("Attempting to fix...") # Prints to original_stdout
                fixed_code = gmc(code_buffer_to_exec, last_instruction_for_fix, error_output_for_llm, previous_task_context_for_fix, current_system_info_for_fix, plan_context_for_fix)
                if fixed_code.startswith("#LLM_ERR"): print(fixed_code)
                elif fixed_code == code_buffer_to_exec: print("LLM: No change.")
                else: print("Fixed."); code_buffer_to_exec = fixed_code; fixed_this_run = True
            finally:
                sys.stdout = original_stdout # Ensure stdout is always restored
                output_str = captured_output.getvalue()
                original_stdout.write(output_str) # Print captured output to actual console
                stdout_lines_capture.extend(output_str.splitlines())
                print_to_original_stdout("--- Live Python Output End (In-Memory) ---", flush=True)
        captured_output.close()
    return code_buffer_to_exec, fixed_this_run, execution_successful, stdout_lines_capture


def start_code_in_background(file_path_to_start):
    global ACTIVE_SUBPROCESS, ACTIVE_SUBPROCESS_FILE
    if not file_path_to_start : print("!No Python file path provided to start."); return
    if not os.path.exists(file_path_to_start): print(f"!Python file to start not found: '{file_path_to_start}'"); return
    if ACTIVE_SUBPROCESS and ACTIVE_SUBPROCESS.poll() is None: print(f"!Process ({ACTIVE_SUBPROCESS_FILE}) already running. Use 'stop' first."); return
    print(f"Starting Python script '{file_path_to_start}' in background...")
    try:
        child_env = os.environ.copy(); child_env["PYTHONUNBUFFERED"] = "1"
        ACTIVE_SUBPROCESS = subprocess.Popen(
            [sys.executable, file_path_to_start], stdout=sys.stdout, stderr=sys.stderr,
            text=True, encoding='utf-8', env=child_env
        )
        ACTIVE_SUBPROCESS_FILE = file_path_to_start
        print(f"'{file_path_to_start}' running (PID: {ACTIVE_SUBPROCESS.pid}). Use 'stop' to terminate.")
    except FileNotFoundError: print(f"!ERROR: Python interpreter '{sys.executable}' not found."); ACTIVE_SUBPROCESS=None
    except Exception as e: print(f"!ERROR starting process: {e}"); ACTIVE_SUBPROCESS=None

def stop_active_subprocess():
    global ACTIVE_SUBPROCESS, ACTIVE_SUBPROCESS_FILE
    if ACTIVE_SUBPROCESS:
        if ACTIVE_SUBPROCESS.poll() is None:
            print(f"Stopping '{ACTIVE_SUBPROCESS_FILE}' (PID: {ACTIVE_SUBPROCESS.pid})..."); ACTIVE_SUBPROCESS.terminate()
            try: ACTIVE_SUBPROCESS.wait(timeout=5)
            except subprocess.TimeoutExpired: print("!SIGTERM timeout, sending SIGKILL..."); ACTIVE_SUBPROCESS.kill(); ACTIVE_SUBPROCESS.wait()
            print("Process stopped.")
        else: print(f"Background process '{ACTIVE_SUBPROCESS_FILE}' was already stopped (Exit: {ACTIVE_SUBPROCESS.returncode}).")
        ACTIVE_SUBPROCESS = None; ACTIVE_SUBPROCESS_FILE = None
    else: print("No active background process to stop.")

def get_process_status():
    global ACTIVE_SUBPROCESS, ACTIVE_SUBPROCESS_FILE
    if ACTIVE_SUBPROCESS:
        poll_result = ACTIVE_SUBPROCESS.poll()
        if poll_result is None: print(f"Process '{ACTIVE_SUBPROCESS_FILE}' (PID: {ACTIVE_SUBPROCESS.pid}) is running.")
        else: print(f"Process '{ACTIVE_SUBPROCESS_FILE}' (PID: {ACTIVE_SUBPROCESS.pid}) has stopped (Exit Code: {poll_result}).")
    else: print("No background process was started or it has been cleared.")

def handle_image_analysis_signal(script_stdout_lines_list):
    for line in script_stdout_lines_list:
        if line.startswith(IMAGE_ANALYSIS_SIGNAL):
            image_path_to_analyze = line.replace(IMAGE_ANALYSIS_SIGNAL, "").strip()
            print(f"\nPOOP: Script signaled to analyze image: '{image_path_to_analyze}'")
            if os.path.exists(image_path_to_analyze):
                try:
                    pil_img = Image.open(image_path_to_analyze)
                    if pil_img.mode != 'RGB': pil_img = pil_img.convert('RGB')
                    print("POOP: Requesting description from multimodal AI...")
                    description = gmc_multimodal(pil_img)
                    pil_img.close()
                    if description.startswith("#LLM_ERR"): print(f"POOP: AI Error: {description}")
                    else: print(f"POOP AI Description of '{os.path.basename(image_path_to_analyze)}':\n---\n{description}\n---")
                    return True # Signal handled
                except FileNotFoundError: print(f"POOP: Error - Image file not found at path from signal: '{image_path_to_analyze}'")
                except ImportError: print("POOP: Error - Pillow (PIL) library is missing. Cannot analyze image.")
                except Exception as e_img: print(f"POOP: Error analyzing image '{image_path_to_analyze}': {e_img}")
            else: print(f"POOP: Error - Image path from signal does not exist: '{image_path_to_analyze}'")
            return True # Signal processed, even if analysis failed
    return False # No signal found or handled


if __name__ == "__main__":
    try: from PIL import Image
    except ImportError: print("!Pillow library is missing. Please install with `pip install Pillow`"); sys.exit(1)

    if not GAK:
        print("ðŸ”‘ GOOGLE_API_KEY is missing.")
        print(f"   Get it here: {API_KEY_LINK}")
        GAK_input = input("   Paste your GOOGLE_API_KEY: ").strip()
        if not GAK_input: print("ðŸ”´ No API key provided. Exiting."); sys.exit(1)
        else: 
            os.environ["GOOGLE_API_KEY"] = GAK_input # Set it for current session
            GAK = GAK_input
            print("âœ… API key OK.")
    else:
        print("âœ… API key found in environment.")

    if not init_llm(): sys.exit(1)

    print(f"\nWelcome to POOP ({POOP_NAME})")
    print_poop_ascii_art()
    print(f"Type 'h' or 'help' for a list of commands.")
    print("----------------------------------------------------")

    current_code_buffer = ""

    while True:
        try:
            # Check if a plan is active and needs to proceed automatically
            if PLAN_CONFIRMED and CURRENT_PLAN_STEPS and PLAN_STEP_INDEX < len(CURRENT_PLAN_STEPS):
                print(f"\nðŸ¤– POOP: Proceeding with plan automatically...")
                # Fall through to the 'else' block logic that handles plan execution
                user_input_raw = "#POOP_CONTINUE_PLAN" # Internal signal to continue plan
            else:
                prompt_color = random.choice(COLORS)
                user_input_raw = input(f"{prompt_color}POOP> {RESET_COLOR}").strip()
                if not user_input_raw: continue

            parts = user_input_raw.lower().split(maxsplit=1)
            command, argument = parts[0], parts[1] if len(parts) > 1 else ""

            current_system_info = get_system_info()

            if command in ['exit', 'quit', 'q']:
                stop_active_subprocess()
                if CURRENT_TARGET_FILE and os.path.exists(CURRENT_TARGET_FILE) and CURRENT_TARGET_FILE.startswith("poop"): # only ask for poop files
                    del_q = input(f"Temporary POOP file '{CURRENT_TARGET_FILE}' exists. Delete? (y/N): ").lower()
                    if del_q == 'y':
                        try: os.remove(CURRENT_TARGET_FILE); print(f"'{CURRENT_TARGET_FILE}' deleted.")
                        except Exception as e: print(f"!Error deleting file '{CURRENT_TARGET_FILE}': {e}")
                print(f"\n{FAREWELL}\n"); break
            elif command in ['help', 'h']: update_cmds_display(); print(CMDS)
            elif command == "sysinfo":
                print("--- Current System Information ---")
                for k, v_sys in current_system_info.items(): print(f"{k.replace('_',' ').title()}: {v_sys}")
                print("--------------------------------")
            elif command in ['model', 'm']:
                if argument:
                    target_model_obj = None
                    # Simplified model switching logic
                    if M_MULTI_CAPABLE_MODEL and (argument == M_MULTI_CAPABLE_MODEL.model_name.split('/')[-1] or argument == "primary" or argument == M_MULTI_CAPABLE_MODEL.model_name) : target_model_obj = M_MULTI_CAPABLE_MODEL
                    elif M_LIGHT_MODEL and (argument == M_LIGHT_MODEL.model_name.split('/')[-1] or argument == "light" or argument == M_LIGHT_MODEL.model_name): target_model_obj = M_LIGHT_MODEL
                    
                    if target_model_obj: M_CURRENT_TEXT_MODEL = target_model_obj; print(f"Model set to: '{M_CURRENT_TEXT_MODEL.model_name}'.")
                    else:
                        print(f"!Model '{argument}' unknown or unavailable. Use 'primary' or 'light' or full name.")
                        print(f"  Available by name/alias: ")
                        if M_MULTI_CAPABLE_MODEL: print(f"    '{M_MULTI_CAPABLE_MODEL.model_name}' (primary, {M_MULTI_CAPABLE_MODEL.model_name.split('/')[-1]})")
                        if M_LIGHT_MODEL and M_LIGHT_MODEL != M_MULTI_CAPABLE_MODEL: print(f"    '{M_LIGHT_MODEL.model_name}' (light, {M_LIGHT_MODEL.model_name.split('/')[-1]})")
                        elif M_LIGHT_MODEL == M_MULTI_CAPABLE_MODEL : print(f"    (Secondary model is same as primary)")
                else:
                    print(f"Current text model: {M_CURRENT_TEXT_MODEL.model_name if M_CURRENT_TEXT_MODEL else 'N/A'}")
                    if M_MULTI_CAPABLE_MODEL: print(f"Primary (multimodal capable) model: {M_MULTI_CAPABLE_MODEL.model_name}")
                    if M_LIGHT_MODEL and M_LIGHT_MODEL != M_MULTI_CAPABLE_MODEL: print(f"Secondary (light) model: {M_LIGHT_MODEL.model_name}")


            elif command == "run":
                if not current_code_buffer.strip():
                    print("!No code in buffer to run.")
                    continue
                confirmed_to_run = False
                if CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN or current_code_buffer != LAST_CODE_FOR_CONFIRMATION:
                    print("\n--- The following Python code was generated/modified (or is unconfirmed) ---")
                    display_code = current_code_buffer
                    # Simple truncation for display
                    if len(display_code) > 1000: display_code = display_code[:500] + "\n...\n(Code truncated)\n...\n" + display_code[-200:]
                    print(f"{display_code}")
                    print("-------------------------------------------------------")
                    confirm = input("Execute this code? (y/N): ").strip().lower()
                    if confirm == 'y':
                        confirmed_to_run = True
                        LAST_CODE_FOR_CONFIRMATION = current_code_buffer
                    else: print("Execution cancelled. Code remains in buffer.")
                else: confirmed_to_run = True

                if confirmed_to_run:
                    target_file_for_run = CURRENT_TARGET_FILE
                    if not target_file_for_run and current_code_buffer.strip(): # If no file, use temp for this run
                        target_file_for_run = generate_unique_poop_filename()
                        print(f"No target file set for run. Using new file: '{target_file_for_run}' for this execution.")
                        # We don't set CURRENT_TARGET_FILE globally here unless it's part of a plan step.
                    
                    # For ad-hoc 'run', the instruction leading to it is LAST_USER_INSTRUCTION
                    # If it's part of a plan, LAST_USER_INSTRUCTION is the overall goal.
                    # For fixing, this context is important.
                    instruction_context_for_run = LAST_USER_INSTRUCTION
                    if PLAN_CONFIRMED and CURRENT_PLAN_STEPS and PLAN_STEP_INDEX < len(CURRENT_PLAN_STEPS) :
                        instruction_context_for_run = f"Plan step: {CURRENT_PLAN_STEPS[PLAN_STEP_INDEX].get('task', 'N/A')} (within overall goal: {LAST_USER_INSTRUCTION})"


                    current_code_buffer, fixed, successful, script_stdout_lines = execute_code(
                        current_code_buffer, instruction_context_for_run, LAST_SUCCESSFUL_TASK_DESCRIPTION,
                        file_path=target_file_for_run # Can be None for in-memory, but file is preferred
                    )
                    CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = fixed # If fixed, it was modified
                    if fixed: LAST_CODE_FOR_CONFIRMATION = "" # Needs re-confirmation if fixed by LLM

                    if successful and not fixed:
                        LAST_SUCCESSFUL_TASK_DESCRIPTION = instruction_context_for_run # What was achieved
                    elif not successful :
                        LAST_SUCCESSFUL_TASK_DESCRIPTION = "" # Failed

                    if successful:
                        handle_image_analysis_signal(script_stdout_lines)

            elif command == "start":
                target_file_for_start = argument if argument else CURRENT_TARGET_FILE
                if not current_code_buffer.strip() and not (target_file_for_start and os.path.exists(target_file_for_start)):
                    print("!No code in buffer and no existing target file to start.")
                    continue
                if not target_file_for_start and current_code_buffer.strip():
                    target_file_for_start = generate_unique_poop_filename()
                    print(f"No target file for start. Using new file for current buffer: '{target_file_for_start}'")
                    CURRENT_TARGET_FILE = target_file_for_start # Set as current if new one is made for start
                    update_cmds_display()
                elif not target_file_for_start and not current_code_buffer.strip(): # Should be caught above
                    print("!Cannot start: No target file specified and code buffer is empty."); continue

                if current_code_buffer.strip():
                    try:
                        with open(target_file_for_start, "w", encoding='utf-8') as f: f.write(current_code_buffer)
                        print(f"Python code written to '{target_file_for_start}'.")
                        start_code_in_background(target_file_for_start)
                    except Exception as e: print(f"!Error writing Python file '{target_file_for_start}': {e}")
                elif os.path.exists(target_file_for_start):
                    print(f"Buffer empty, starting existing file '{target_file_for_start}'...")
                    start_code_in_background(target_file_for_start)
                else: print(f"!No code in buffer and target file '{target_file_for_start}' not found.")

                if current_code_buffer.strip(): # If buffer was used, mark as "not modified by LLM since last run"
                    CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = False
                    LAST_CODE_FOR_CONFIRMATION = current_code_buffer
                    # Assuming 'start' means the task related to LAST_USER_INSTRUCTION is now running.
                    LAST_SUCCESSFUL_TASK_DESCRIPTION = LAST_USER_INSTRUCTION


            elif command == "stop": stop_active_subprocess()
            elif command == "status_process": get_process_status()
            elif command == "img_desc":
                if not argument: print("!Path to image required."); continue
                if not M_MULTI_CAPABLE_MODEL: print("!Multimodal model (primary) not available for img_desc."); continue
                try:
                    image_path = os.path.abspath(argument)
                    if not os.path.exists(image_path): print(f"!Image not found: '{image_path}'"); continue
                    print(f"Loading: '{image_path}'...");
                    pil_image = Image.open(image_path)
                    if pil_image.mode != 'RGB': pil_image = pil_image.convert('RGB')
                    print("Generating image description...");
                    description = gmc_multimodal(pil_image)
                    if description.startswith("#LLM_ERR"): print(f"Error: {description}")
                    else: print(f"\n--- Image Description ---\n{description}\n------------------------")
                except Exception as e: print(f"!Error processing image: {e}")

            elif command == "show":
                print(f"PYTHON CODE ({len(current_code_buffer)} B):\n{'-'*30}\n{current_code_buffer}\n{'-'*30}" if current_code_buffer.strip() else "!Python code buffer is empty.")
                if CURRENT_TARGET_FILE: print(f"Python Target File: {CURRENT_TARGET_FILE}")
                else: print("Python Target: In-Memory / New unique file on next generation/run/plan.")
                if LAST_SUCCESSFUL_TASK_DESCRIPTION: print(f"Last successful task context: {LAST_SUCCESSFUL_TASK_DESCRIPTION}")
                if CURRENT_PLAN_TEXT:
                    print("\n--- Active Plan ---")
                    for i, step_show in enumerate(CURRENT_PLAN_STEPS):
                        status_char = "âœ…" if i < PLAN_STEP_INDEX else ("â³" if i == PLAN_STEP_INDEX and PLAN_CONFIRMED else "ðŸ“‹")
                        print(f"{status_char} {i+1}. Task: {step_show.get('task','N/A')}")
                        if i == PLAN_STEP_INDEX and PLAN_CONFIRMED: print("    (Next step to execute)")
                    if PLAN_STEP_INDEX >= len(CURRENT_PLAN_STEPS) and PLAN_CONFIRMED : print("ðŸŽ‰ Plan Completed!")
                    elif not PLAN_CONFIRMED and CURRENT_PLAN_STEPS: print("ðŸ•’ Plan Awaiting Confirmation.")
                    print("-------------------")


            elif command == "clear":
                current_code_buffer = ""; LAST_USER_INSTRUCTION = "print('Hello from POOP!')"; LAST_SUCCESSFUL_TASK_DESCRIPTION = ""
                CURRENT_TARGET_FILE = None
                CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = False; LAST_CODE_FOR_CONFIRMATION = ""
                CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = []; PLAN_CONFIRMED = False; PLAN_STEP_INDEX = 0
                print("Python code buffer, task history, and active plan cleared. Target file reset.")
                update_cmds_display()

            elif command in ["file", "f"]:
                if argument.lower() == "none" or argument.lower() == "--clear":
                    if CURRENT_TARGET_FILE and os.path.exists(CURRENT_TARGET_FILE) and CURRENT_TARGET_FILE.startswith("poop"):
                        del_q = input(f"Temporary POOP file '{CURRENT_TARGET_FILE}' exists. Delete? (y/N): ").lower()
                        if del_q == 'y':
                            try: os.remove(CURRENT_TARGET_FILE); print(f"'{CURRENT_TARGET_FILE}' deleted.")
                            except Exception as e: print(f"!Error deleting file '{CURRENT_TARGET_FILE}': {e}")
                    CURRENT_TARGET_FILE = None; print("Mode: In-Memory Python execution / New file per plan. Target file reset.")
                    LAST_SUCCESSFUL_TASK_DESCRIPTION = ""
                elif argument:
                    new_target_file = os.path.abspath(argument)
                    CURRENT_TARGET_FILE = new_target_file
                    print(f"Python target file set to: '{CURRENT_TARGET_FILE}'.")
                    if os.path.exists(CURRENT_TARGET_FILE):
                        try:
                            with open(CURRENT_TARGET_FILE, 'r', encoding='utf-8') as f: current_code_buffer = f.read()
                            print(f"Content of '{CURRENT_TARGET_FILE}' ({len(current_code_buffer)} B) loaded into buffer.")
                            LAST_USER_INSTRUCTION = f"# Code loaded from {CURRENT_TARGET_FILE}" # Update last instruction
                            LAST_SUCCESSFUL_TASK_DESCRIPTION = f"Code loaded from file '{CURRENT_TARGET_FILE}'"
                        except Exception as e: print(f"!Error loading file: {e}"); current_code_buffer = ""; LAST_SUCCESSFUL_TASK_DESCRIPTION = ""
                    else:
                        print(f"File '{CURRENT_TARGET_FILE}' does not exist. It will be created if code is generated/run.")
                        LAST_SUCCESSFUL_TASK_DESCRIPTION = ""
                else:
                    if CURRENT_TARGET_FILE: print(f"Current Python target file: '{CURRENT_TARGET_FILE}'")
                    else: print("Current Python Target: In-Memory / New unique file on next generation/run/plan.")
                CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = False # Assume loaded code is "trusted" or needs run to confirm
                LAST_CODE_FOR_CONFIRMATION = current_code_buffer
                # Setting a file should not clear an active plan unless intended.
                # For now, it doesn't clear the plan. User can use 'clear' for that.
                update_cmds_display()

            # Main logic for handling general instructions -> planning and execution
            else:
                if command != "#poop_continue_plan": # Don't overwrite if it's an internal signal
                    LAST_USER_INSTRUCTION = user_input_raw # This is the high-level goal

                # --- PLAN EXECUTION ---
                if PLAN_CONFIRMED and CURRENT_PLAN_STEPS and PLAN_STEP_INDEX < len(CURRENT_PLAN_STEPS):
                    current_step_details = CURRENT_PLAN_STEPS[PLAN_STEP_INDEX]
                    step_task = current_step_details.get('task', f"Unnamed Step {PLAN_STEP_INDEX + 1}")
                    print(f"\nðŸ¤– POOP: Executing Plan Step {PLAN_STEP_INDEX + 1}/{len(CURRENT_PLAN_STEPS)}: {step_task}")

                    if current_step_details.get("requires_code_gen", True):
                        instruction_for_gmc = f"Implement this plan step: {step_task}."
                        if current_step_details.get('details'):
                            instruction_for_gmc += f" Additional details for this step: {current_step_details['details']}."
                        if current_step_details.get('requires_user_input_during_step'):
                            instruction_for_gmc += f" The script should prompt the user for: {current_step_details['requires_user_input_during_step']}."
                        if current_step_details.get('screenshot_analysis_signal', False):
                             instruction_for_gmc += f" This step is expected to take a screenshot for POOP to analyze; ensure the signal '{IMAGE_ANALYSIS_SIGNAL} <filepath>' is printed."

                        code_base_for_step = current_code_buffer if current_step_details.get("additive_code", False) else ""
                        
                        print("POOP: Generating code for this step...")
                        gmc_plan_context = {
                            "full_plan": CURRENT_PLAN_TEXT,
                            "current_step_description": step_task,
                            "current_step_details": current_step_details.get('details', 'N/A'),
                            "requires_user_input_during_step": current_step_details.get('requires_user_input_during_step'),
                            "screenshot_analysis_signal": current_step_details.get('screenshot_analysis_signal', False)
                        }
                        generated_code_for_step = gmc(
                            code_base_for_step,
                            instruction_for_gmc,
                            previous_task_context_for_code_gen=LAST_SUCCESSFUL_TASK_DESCRIPTION,
                            system_info_for_code_gen=current_system_info,
                            plan_context_for_code_gen=gmc_plan_context
                        )

                        if generated_code_for_step.startswith("#LLM_ERR"):
                            print(generated_code_for_step)
                            print("POOP: Halting plan execution due to code generation error for this step.")
                            PLAN_CONFIRMED = False # Stop auto-proceeding
                        elif not generated_code_for_step.strip():
                            print("LLM: Returned empty code for this step. Assuming no direct code action or error.")
                            # This might be a misinterpretation by LLM or an actual "no code" step it forgot to mark.
                            # For now, we try to advance if the plan allows non-code steps, or halt.
                            LAST_SUCCESSFUL_TASK_DESCRIPTION = f"Acknowledged plan step (no code generated): {step_task}"
                            PLAN_STEP_INDEX += 1 # Tentatively advance
                            if PLAN_STEP_INDEX >= len(CURRENT_PLAN_STEPS):
                                print("\nðŸ¤– POOP: Plan Succeeded! All steps completed.")
                                CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = []; PLAN_CONFIRMED = False; PLAN_STEP_INDEX = 0
                        else:
                            if current_step_details.get("additive_code", False) and current_code_buffer:
                                current_code_buffer += "\n\n# Code for step: " + step_task + "\n" + generated_code_for_step
                            else:
                                current_code_buffer = generated_code_for_step
                            
                            CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = True # Code is new from LLM
                            LAST_CODE_FOR_CONFIRMATION = "" # Needs no interactive confirmation as plan was approved

                            if not CURRENT_TARGET_FILE or not current_step_details.get("additive_code", False):
                                # Generate a new file for non-additive steps or if no file exists
                                CURRENT_TARGET_FILE = generate_unique_poop_filename()
                                print(f"POOP: Using new target file for this step: '{CURRENT_TARGET_FILE}'")
                                update_cmds_display()
                            
                            if CURRENT_TARGET_FILE:
                                try:
                                    with open(CURRENT_TARGET_FILE, "w", encoding='utf-8') as f: f.write(current_code_buffer)
                                    print(f"Code for step saved to '{CURRENT_TARGET_FILE}'.")
                                except Exception as e: print(f"!Error saving code to '{CURRENT_TARGET_FILE}': {e}")
                            
                            print(f"\nPOOP: Automatically running code for step: {step_task}")
                            current_code_buffer, fixed, successful, script_stdout_lines = execute_code(
                                current_code_buffer,
                                instruction_for_gmc,
                                LAST_SUCCESSFUL_TASK_DESCRIPTION,
                                file_path=CURRENT_TARGET_FILE, # Always use file for plan execution
                                auto_run_source=f"POOP (Plan Step {PLAN_STEP_INDEX + 1}): "
                            )
                            CODE_MODIFIED_BY_LLM_SINCE_LAST_RUN = fixed # If LLM fixed it, it's "modified"
                            if fixed: LAST_CODE_FOR_CONFIRMATION = ""

                            if successful and not fixed:
                                print(f"POOP: Plan step {PLAN_STEP_INDEX + 1} executed successfully.")
                                LAST_SUCCESSFUL_TASK_DESCRIPTION = f"Completed plan step: {step_task} (Part of: {LAST_USER_INSTRUCTION})"
                                PLAN_STEP_INDEX += 1
                                handle_image_analysis_signal(script_stdout_lines)
                                if PLAN_STEP_INDEX >= len(CURRENT_PLAN_STEPS):
                                    print("\nðŸ¤– POOP: Plan Succeeded! All steps completed.")
                                    CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = []; PLAN_CONFIRMED = False; PLAN_STEP_INDEX = 0
                            else: # Failed or fixed but needs re-eval / human check
                                print(f"!POOP: Plan step {PLAN_STEP_INDEX + 1} did not complete successfully (original or after fix).")
                                LAST_SUCCESSFUL_TASK_DESCRIPTION = ""
                                print("POOP: Halting plan execution. Please review the error and code. You can try 'run' to re-run current buffer or provide a new instruction.")
                                PLAN_CONFIRMED = False # Stop auto-proceeding
                    
                    else: # Step does not require code generation by POOP
                        print(f"POOP: Plan step '{step_task}' is marked as not requiring POOP code generation.")
                        if current_step_details.get('details'): print(f"       Details: {current_step_details['details']}")
                        
                        if current_step_details.get('requires_user_action'):
                            print(f"       USER ACTION REQUIRED: {current_step_details['requires_user_action']}")
                            user_confirms_action = input("POOP: Have you completed this manual step as described? (y/N): ").strip().lower()
                            if user_confirms_action == 'y':
                                print("POOP: User confirmed manual step completion.")
                                LAST_SUCCESSFUL_TASK_DESCRIPTION = f"User confirmed completion of manual plan step: {step_task}"
                                PLAN_STEP_INDEX += 1
                            else:
                                print("POOP: Plan paused. Please complete the manual step. Type any command or press Enter to allow POOP to re-check plan status.")
                                PLAN_CONFIRMED = False # Effectively pauses, requires user to "wake up" POOP
                        else: # No code gen, no specific user action -> informational or LLM handles internally
                            print("POOP: Acknowledging informational step.")
                            LAST_SUCCESSFUL_TASK_DESCRIPTION = f"Acknowledged informational plan step: {step_task}"
                            PLAN_STEP_INDEX += 1 # Move to next step

                        if PLAN_STEP_INDEX >= len(CURRENT_PLAN_STEPS) and PLAN_CONFIRMED : # PLAN_CONFIRMED check because user action pause sets it to False
                            print("\nðŸ¤– POOP: Plan Succeeded! All steps completed.")
                            CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = []; PLAN_CONFIRMED = False; PLAN_STEP_INDEX = 0
                
                # --- PLAN GENERATION ---
                elif not CURRENT_PLAN_TEXT and command != "#poop_continue_plan": # No active plan, try to generate one
                    print(f"ðŸ¤– POOP: Understood high-level instruction: '{LAST_USER_INSTRUCTION}'. Generating a plan...")
                    plan_text_output = gmp(LAST_USER_INSTRUCTION, current_system_info)

                    if plan_text_output.startswith("#LLM_ERR"):
                        print(plan_text_output)
                    elif not plan_text_output.strip():
                        print("POOP: LLM returned an empty plan. Please try rephrasing your instruction or be more specific.")
                    else:
                        CURRENT_PLAN_TEXT = plan_text_output
                        # print(f"DEBUG: Raw plan text to parse:\n{CURRENT_PLAN_TEXT}") # For debugging
                        CURRENT_PLAN_STEPS = parse_plan(CURRENT_PLAN_TEXT)
                        # print(f"DEBUG: Parsed steps: {CURRENT_PLAN_STEPS}") # For debugging

                        if not CURRENT_PLAN_STEPS:
                            print("POOP: Could not parse a structured plan from LLM. Raw plan output was:")
                            print(CURRENT_PLAN_TEXT)
                            CURRENT_PLAN_TEXT = "" # Clear invalid plan
                        else:
                            print("\n--- POOP Proposed Plan ---")
                            for i, step_disp in enumerate(CURRENT_PLAN_STEPS):
                                print(f"{i+1}. Task: {step_disp.get('task','N/A')}")
                                if step_disp.get('details'): print(f"   Details: {step_disp['details']}")
                                if step_disp.get('dependencies'): print(f"   Dependencies: {step_disp['dependencies']}")
                                if step_disp.get('outcome'): print(f"   Outcome: {step_disp['outcome']}")
                                print(f"   Requires Code Gen: {'Yes' if step_disp.get('requires_code_gen', True) else 'No'}")
                                if step_disp.get('requires_code_gen', True):
                                    print(f"   Additive Code: {'Yes' if step_disp.get('additive_code', False) else 'No'}")
                                    if step_disp.get('screenshot_analysis_signal', False) : print(f"   Screenshot Analysis Signal: Yes")

                                if step_disp.get('requires_user_input_during_step'): print(f"   Requires User Input During Step: {step_disp['requires_user_input_during_step']}")
                                if step_disp.get('requires_user_action'): print(f"   Requires User Action: {step_disp['requires_user_action']}")
                            print("--------------------------")
                            confirm_plan_input = input("Proceed with this plan? (y/N/edit): ").strip().lower()
                            if confirm_plan_input == 'y':
                                PLAN_CONFIRMED = True
                                PLAN_STEP_INDEX = 0
                                CURRENT_TARGET_FILE = None # Reset target file for the new plan execution
                                current_code_buffer = ""   # Reset code buffer for the new plan
                                LAST_SUCCESSFUL_TASK_DESCRIPTION = f"Plan confirmed for: {LAST_USER_INSTRUCTION}"
                                print("POOP: Plan confirmed. Will start executing step 1 on next interaction or automatically.")
                                # The loop will re-enter and pick up the first step.
                            elif confirm_plan_input == 'edit':
                                print("POOP: Plan editing not yet implemented. Please refine your initial instruction or reject and try again.")
                                CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = [] # Discard plan
                            else:
                                print("POOP: Plan rejected.")
                                CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = [] # Discard plan
                elif command == "#poop_continue_plan" and (not PLAN_CONFIRMED or PLAN_STEP_INDEX >= len(CURRENT_PLAN_STEPS)):
                    # Plan finished or was unconfirmed, waiting for new user input
                    if PLAN_STEP_INDEX >= len(CURRENT_PLAN_STEPS) and CURRENT_PLAN_STEPS: # Was a plan and it finished
                         print("ðŸ¤– POOP: Plan execution finished. Waiting for new instruction.")
                         CURRENT_PLAN_TEXT = ""; CURRENT_PLAN_STEPS = []; PLAN_CONFIRMED = False; PLAN_STEP_INDEX = 0
                    # else: just loop for new input if #poop_continue_plan but nothing to do

        except KeyboardInterrupt:
            print(f"\n{random.choice(COLORS)}POOP> {RESET_COLOR}Input cancelled. Use 'q' to exit.")
            if PLAN_CONFIRMED:
                print("POOP: Plan execution paused due to interruption.")
                PLAN_CONFIRMED = False # Stop auto-proceeding until user interacts again
        except Exception as e:
            print(f"\n!UNEXPECTED ERROR in main POOP loop: {e}")
            traceback.print_exc()
            if PLAN_CONFIRMED:
                print("POOP: Plan execution halted due to unexpected error.")
                PLAN_CONFIRMED = False # Stop auto-proceeding
